(include "src/base.egg")

;; Define operations
(function linalg_matmul (Op Op Op Type) Op)
(function tensor_empty (Type) Op)

;; OPS HERE ;;
; _2mm_both_func.func
(let op0 (Value 0 (RankedTensor (vec-of 100 10) (I64))))
(let op1 (Value 1 (RankedTensor (vec-of 10 150) (I64))))
(let op2 (Value 2 (RankedTensor (vec-of 150 8) (I64))))
(let op3 (tensor_empty (RankedTensor (vec-of 100 150) (I64))))
(let op4 (linalg_matmul op0 op1 op3 (RankedTensor (vec-of 100 150) (I64))))
(let op5 (tensor_empty (RankedTensor (vec-of 100 8) (I64))))
(let op6 (linalg_matmul op4 op2 op5 (RankedTensor (vec-of 100 8) (I64))))
(let op7 (tensor_empty (RankedTensor (vec-of 10 8) (I64))))
(let op8 (linalg_matmul op1 op2 op7 (RankedTensor (vec-of 10 8) (I64))))
(let op9 (tensor_empty (RankedTensor (vec-of 100 8) (I64))))
(let op10 (linalg_matmul op0 op8 op9 (RankedTensor (vec-of 100 8) (I64))))
(let op11 (Value 11 (None)))

;; RULES HERE ;;
(ruleset matmul_assoc)

; Helper functions for matrix dimensions
(function nrows (Type) i64)
(function ncols (Type) i64)

; Extract dimensions from RankedTensor types
(rule ((= ?t (RankedTensor ?shape ?tp))) 
    ((set (nrows ?t) (vec-get ?shape 0)) 
     (set (ncols ?t) (vec-get ?shape 1)))
    :ruleset matmul_assoc
)

; Set type information for operations
(rule ((= ?A (Value ?id ?t))) ((set (type-of ?A) ?t)) :ruleset matmul_assoc)
(rule ((= ?A (linalg_matmul ?x ?y ?o ?t))) ((set (type-of ?A) ?t)) :ruleset matmul_assoc)
(rule ((= ?A (tensor_empty ?t))) ((set (type-of ?A) ?t)) :ruleset matmul_assoc)

; Matrix multiplication associativity rule
(rule
    ((= ?lhs (linalg_matmul (linalg_matmul ?x ?y ?xy ?xy_t) ?z ?xy_z ?xyz_t))
     (= ?b (nrows (type-of ?y)))
     (= ?d (ncols (type-of ?z)))
     (= ?xyz_t (RankedTensor ? ?t)))
    
    ((let out_t (RankedTensor (vec-of ?b ?d) ?t))
     (union ?lhs (linalg_matmul ?x (linalg_matmul ?y ?z (tensor_empty out_t) out_t) ?xy_z ?xyz_t)))
    :ruleset matmul_assoc
)

;; Run saturation
(run-schedule (saturate matmul_assoc))

;; EXTRACTS HERE ;;
(extract op6)
(extract op10)
;; Extract both expressions to check if they're equivalent
(extract op6)   ; (X * Y) * Z result
(extract op10)  ; X * (Y * Z) result
;; Check if they're in the same e-class
(check (= op6 op10)) 
