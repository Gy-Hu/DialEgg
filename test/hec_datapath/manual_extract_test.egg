(include "src/base.egg")

;;;; Manual HEC Datapath Verification Test ;;;;

;; Define arithmetic operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op) 
(function arith_xori (Op Op Type) Op)

;; Define test operations manually
(let input_a (Value 0 (I1)))
(let input_b (Value 1 (I1)))
(let c_true (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))

;; Test double negation elimination: NOT(NOT(a)) = a
(let not_a (arith_xori input_a c_true (I1)))
(let not_not_a (arith_xori not_a c_true (I1)))

;; Test NAND and De Morgan's equivalence
(let and_result (arith_andi input_a input_b (I1)))
(let nand_result (arith_xori and_result c_true (I1)))

;; De Morgan's equivalent: OR(NOT(a), NOT(b))  
(let not_b (arith_xori input_b c_true (I1)))
(let demorgan_result (arith_ori not_a not_b (I1)))

;; Rules
(ruleset hec_boolean_rules)

;; Double negation elimination: ¬¬a = a
(rewrite 
    (arith_xori (arith_xori ?a c_true (I1)) c_true (I1))
    ?a
    :ruleset hec_boolean_rules
)

;; De Morgan's law: ¬(a & b) = ¬a | ¬b
(rewrite 
    (arith_xori (arith_andi ?a ?b (I1)) c_true (I1))
    (arith_ori (arith_xori ?a c_true (I1)) (arith_xori ?b c_true (I1)) (I1))
    :ruleset hec_boolean_rules
)

;; Run equality saturation
(run-schedule (saturate hec_boolean_rules))

;; Extract results to verify transformations
(extract not_not_a)  ; Should simplify to input_a
(extract nand_result) ; Should be equivalent to demorgan_result
(extract demorgan_result) ; Should be equivalent to nand_result 