(include "src/base.egg")

;;;; Extended HEC Datapath Verification Rules ;;;;
;;;; Boolean Algebra, Arithmetic, and Bitwise transformations ;;;;

;; Define arithmetic and bitwise operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op) 
(function arith_xori (Op Op Type) Op)
(function arith_muli (Op Op Type) Op)
(function arith_addi (Op Op Type) Op)
(function arith_shli (Op Op Type) Op)  ; Left shift
(function arith_shrui (Op Op Type) Op) ; Right shift unsigned
(function affine_load (Op Op Type) Op)
(function affine_store (Op Op Type) Op)
(function affine_for (Op Op Op Block) Op)

;; OPS HERE ;;

;; RULES HERE ;;
(ruleset hec_extended_rules)

;; Define common constants for different bit widths
(let c_true_i1 (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))
(let c_false_i1 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I1))) (I1)))
(let c_0_i32 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I32))) (I32)))
(let c_1_i32 (arith_constant (NamedAttr "value" (IntegerAttr 1 (I32))) (I32)))
(let c_2_i32 (arith_constant (NamedAttr "value" (IntegerAttr 2 (I32))) (I32)))

;;;; Boolean Algebra Rules (from previous implementation) ;;;;

;; De Morgan's laws
(rewrite 
    (arith_xori (arith_andi ?a ?b (I1)) c_true_i1 (I1))
    (arith_ori (arith_xori ?a c_true_i1 (I1)) (arith_xori ?b c_true_i1 (I1)) (I1))
    :ruleset hec_extended_rules
)

;; Double negation elimination
(rewrite 
    (arith_xori (arith_xori ?a c_true_i1 (I1)) c_true_i1 (I1))
    ?a
    :ruleset hec_extended_rules
)

;;;; Arithmetic Transformation Rules (HEC Paper Table 1) ////

;; Shift to multiplication: a << b = a × 2^b (for constant shifts)
(rewrite 
    (arith_shli ?a c_1_i32 (I32))
    (arith_muli ?a c_2_i32 (I32))
    :ruleset hec_extended_rules
)

;; Multiplication by powers of 2: a × 2 = a << 1
(rewrite 
    (arith_muli ?a c_2_i32 (I32))
    (arith_shli ?a c_1_i32 (I32))
    :ruleset hec_extended_rules
)

;; Multiplication associativity: (a × b) × c = a × (b × c)
(rewrite 
    (arith_muli (arith_muli ?a ?b ?t1) ?c ?t2)
    (arith_muli ?a (arith_muli ?b ?c ?t1) ?t2)
    :ruleset hec_extended_rules
)

;; Addition associativity: (a + b) + c = a + (b + c)
(rewrite 
    (arith_addi (arith_addi ?a ?b ?t1) ?c ?t2)
    (arith_addi ?a (arith_addi ?b ?c ?t1) ?t2)
    :ruleset hec_extended_rules
)

;; Shift composition: (a << b) << c = a << (b + c) (for constants)
(rewrite 
    (arith_shli (arith_shli ?a ?b ?t1) ?c ?t2)
    (arith_shli ?a (arith_addi ?b ?c ?t1) ?t2)
    :ruleset hec_extended_rules
)

;; Multiplication identity: a × 1 = a
(rewrite 
    (arith_muli ?a c_1_i32 (I32))
    ?a
    :ruleset hec_extended_rules
)

;; Addition identity: a + 0 = a
(rewrite 
    (arith_addi ?a c_0_i32 (I32))
    ?a
    :ruleset hec_extended_rules
)

;; Commutative rules for arithmetic
(rewrite (arith_muli ?x ?y ?t) (arith_muli ?y ?x ?t) :ruleset hec_extended_rules)
(rewrite (arith_addi ?x ?y ?t) (arith_addi ?y ?x ?t) :ruleset hec_extended_rules)

;; XOR properties
(rewrite (arith_xori ?x ?x ?t) c_false_i1 :ruleset hec_extended_rules) ; a ^ a = 0
(rewrite (arith_xori ?x c_false_i1 ?t) ?x :ruleset hec_extended_rules) ; a ^ 0 = a

;; Run the equality saturation
(run-schedule (saturate hec_extended_rules))

;; EXTRACTS HERE ;; 