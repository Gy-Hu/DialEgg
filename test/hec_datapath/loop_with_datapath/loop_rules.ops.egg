(include "src/base.egg")

;; Define operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op)
(function arith_xori (Op Op Type) Op)
(function affine_load (Op Op Type) Op)
(function affine_store (Op Op Op) Op)
(function affine_for (Op Op Op Block) Op)

;; OPS HERE ;;
; simple_loop_test_func.func
(let op0 (Value 0 (OpaqueType "memref<1xi1>" "builtin.memref")))
(let op1 (Value 1 (OpaqueType "memref<1xi1>" "builtin.memref")))
(let op2 (Value 2 (I1)))
(let op3 (Value 3 (I1)))
(let op4 (arith_andi op2 op3 (I1)))
(let op5 (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))
(let op6 (arith_xori op4 op5 (I1)))
(let op7 (arith_xori op2 op5 (I1)))
(let op8 (arith_xori op3 op5 (I1)))
(let op9 (arith_ori op7 op8 (I1)))
(let op10 (Value 10 (None)))

;; RULES HERE ;;
(ruleset demorgan)

;; De Morgan's law: ¬(a & b) = ¬a | ¬b
(rewrite
    (arith_xori 
        (arith_andi ?a ?b (I1)) 
        (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) 
        (I1))
    (arith_ori 
        (arith_xori ?a (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (arith_xori ?b (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (I1))
    :ruleset demorgan
)

;; Run saturation
(run-schedule (saturate demorgan))

;; EXTRACTS HERE ;;
(extract op6)
(extract op9)
;; Extract the NAND and OR expressions
(extract op6)   ; NAND result (arith.xori %2, %true)
(extract op9)   ; OR result (arith.ori %4, %5)
;; Check if they're equivalent
(check (= op6 op9)) 
