(include "src/base.egg")

;; Define operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op)
(function arith_xori (Op Op Type) Op)
(function affine_load (Op Op Type) Op)
(function affine_store (Op Op Op) Op)
(function affine_for (Op Op Op Block) Op)

;; OPS HERE ;;

;; RULES HERE ;;
(ruleset demorgan)

;; De Morgan's law: ¬(a & b) = ¬a | ¬b
(rewrite
    (arith_xori 
        (arith_andi ?a ?b (I1)) 
        (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) 
        (I1))
    (arith_ori 
        (arith_xori ?a (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (arith_xori ?b (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (I1))
    :ruleset demorgan
)

;; Run saturation
(run-schedule (saturate demorgan))

;; EXTRACTS HERE ;;
;; Extract the NAND and OR expressions
(extract op6)   ; NAND result (arith.xori %2, %true)
(extract op9)   ; OR result (arith.ori %4, %5)
;; Check if they're equivalent
(check (= op6 op9)) 