(include "src/base.egg")

;; Define operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op)
(function arith_xori (Op Op Type) Op)

;; OPS HERE ;;
; test_equivalence_func.func
(let op0 (Value 0 (I1)))
(let op1 (Value 1 (I1)))
(let op2 (arith_andi op0 op1 (I1)))
(let op3 (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))
(let op4 (arith_xori op2 op3 (I1)))
(let op5 (arith_xori op0 op3 (I1)))
(let op6 (arith_xori op1 op3 (I1)))
(let op7 (arith_ori op5 op6 (I1)))
(let op8 (Value 8 (None)))

;; RULES HERE ;;
(ruleset demorgan)

;; De Morgan's law
(rewrite
    (arith_xori 
        (arith_andi ?a ?b (I1)) 
        (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) 
        (I1))
    (arith_ori 
        (arith_xori ?a (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (arith_xori ?b (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
        (I1))
    :ruleset demorgan
)

;; Run saturation
(run-schedule (saturate demorgan))

;; EXTRACTS HERE ;;
(extract op4)
(extract op7)
;; Extract both expressions to check if they're equivalent
(extract op4)  ; NAND result
(extract op7)  ; OR result
;; Check if they're in the same e-class
(check (= op4 op8)) 
