(include "src/base.egg")

;; Define operations
(function arith_constant (AttrPair Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op)
(function arith_xori (Op Op Type) Op)

;; Define the operations from MLIR
(let op0 (Value 0 (I1)))  ; arg0
(let op1 (Value 1 (I1)))  ; arg1
(let op2 (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))  ; true
(let op3 (arith_xori op0 op1 (I1)))  ; direct XOR
(let op4 (arith_xori op0 op2 (I1)))  ; NOT a
(let op5 (arith_xori op1 op2 (I1)))  ; NOT b
(let op6 (arith_andi op0 op5 (I1)))  ; a AND NOT b
(let op7 (arith_andi op4 op1 (I1)))  ; NOT a AND b
(let op8 (arith_ori op6 op7 (I1)))   ; (a AND NOT b) OR (NOT a AND b)

;; RULES
(ruleset xor_expansion)

;; XOR expansion: a ⊕ b = (a ∧ ¬b) ∨ (¬a ∧ b)
(rewrite
    (arith_xori ?a ?b (I1))
    (arith_ori 
        (arith_andi 
            ?a 
            (arith_xori ?b (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1)) 
            (I1))
        (arith_andi 
            (arith_xori ?a (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)) (I1))
            ?b 
            (I1))
        (I1))
    :ruleset xor_expansion
)

;; Run saturation
(run-schedule (saturate xor_expansion))

;; Extract both operations
(extract op3)  ; Direct XOR
(extract op8)  ; Expanded XOR

;; Check if op3 (direct XOR) equals op8 (expanded XOR)
(check (= op3 op8)) 