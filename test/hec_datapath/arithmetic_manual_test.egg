(include "src/base.egg")

;;;; Manual HEC Arithmetic Transformation Test ////

;; Define arithmetic operations
(function arith_constant (AttrPair Type) Op)
(function arith_muli (Op Op Type) Op)
(function arith_addi (Op Op Type) Op)
(function arith_shli (Op Op Type) Op)
(function arith_xori (Op Op Type) Op)
(function arith_andi (Op Op Type) Op)
(function arith_ori (Op Op Type) Op)

;; Define test values
(let input_a (Value 0 (I32)))
(let input_b (Value 1 (I32)))

;; Constants
(let c_0 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I32))) (I32)))
(let c_1 (arith_constant (NamedAttr "value" (IntegerAttr 1 (I32))) (I32)))
(let c_2 (arith_constant (NamedAttr "value" (IntegerAttr 2 (I32))) (I32)))
(let c_4 (arith_constant (NamedAttr "value" (IntegerAttr 4 (I32))) (I32)))

;; Test 1: Multiplication vs Shift equivalence (a * 2 = a << 1)
(let mul_by_2 (arith_muli input_a c_2 (I32)))
(let shift_by_1 (arith_shli input_a c_1 (I32)))

;; Test 2: Shift composition ((a << 1) << 1 = a << 2)
(let double_shift (arith_shli shift_by_1 c_1 (I32)))
(let shift_by_2 (arith_shli input_a c_2 (I32)))

;; Test 3: Multiplication associativity ((a * 2) * 2 = a * (2 * 2))
(let left_assoc (arith_muli mul_by_2 c_2 (I32)))
(let const_4_mul (arith_muli c_2 c_2 (I32)))
(let right_assoc (arith_muli input_a const_4_mul (I32)))

;; Test 4: Addition associativity
(let add_ab (arith_addi input_a input_b (I32)))
(let left_add_assoc (arith_addi add_ab c_1 (I32)))
(let add_bc (arith_addi input_b c_1 (I32)))
(let right_add_assoc (arith_addi input_a add_bc (I32)))

;; Boolean constants for mixed testing
(let c_true (arith_constant (NamedAttr "value" (IntegerAttr -1 (I1))) (I1)))
(let bool_a (Value 2 (I1)))
(let bool_b (Value 3 (I1)))

;; Test 5: Double negation with XOR
(let not_a (arith_xori bool_a c_true (I1)))
(let not_not_a (arith_xori not_a c_true (I1)))

;; Rules
(ruleset hec_extended_rules)

;; Arithmetic transformation rules
(rewrite (arith_muli ?a c_2 (I32)) (arith_shli ?a c_1 (I32)) :ruleset hec_extended_rules)
(rewrite (arith_shli ?a c_1 (I32)) (arith_muli ?a c_2 (I32)) :ruleset hec_extended_rules)

;; Shift composition
(rewrite 
    (arith_shli (arith_shli ?a c_1 (I32)) c_1 (I32))
    (arith_shli ?a c_2 (I32))
    :ruleset hec_extended_rules
)

;; Multiplication associativity  
(rewrite 
    (arith_muli (arith_muli ?a ?b (I32)) ?c (I32))
    (arith_muli ?a (arith_muli ?b ?c (I32)) (I32))
    :ruleset hec_extended_rules
)

;; Addition associativity
(rewrite 
    (arith_addi (arith_addi ?a ?b (I32)) ?c (I32))
    (arith_addi ?a (arith_addi ?b ?c (I32)) (I32))
    :ruleset hec_extended_rules
)

;; Multiplication identity
(rewrite (arith_muli ?a c_1 (I32)) ?a :ruleset hec_extended_rules)

;; Addition identity  
(rewrite (arith_addi ?a c_0 (I32)) ?a :ruleset hec_extended_rules)

;; Constant folding for multiplication
(rewrite (arith_muli c_2 c_2 (I32)) c_4 :ruleset hec_extended_rules)

;; Double negation elimination
(rewrite 
    (arith_xori (arith_xori ?a c_true (I1)) c_true (I1))
    ?a
    :ruleset hec_extended_rules
)

;; Commutative rules
(rewrite (arith_muli ?x ?y ?t) (arith_muli ?y ?x ?t) :ruleset hec_extended_rules)
(rewrite (arith_addi ?x ?y ?t) (arith_addi ?y ?x ?t) :ruleset hec_extended_rules)

;; Run equality saturation
(run-schedule (saturate hec_extended_rules))

;; Extract results to verify transformations
(extract mul_by_2)        ; Should be equivalent to shift_by_1
(extract shift_by_1)      ; Should be equivalent to mul_by_2
(extract double_shift)    ; Should be equivalent to shift_by_2  
(extract shift_by_2)      ; Should be equivalent to double_shift
(extract left_assoc)      ; Should be equivalent to right_assoc
(extract right_assoc)     ; Should be equivalent to left_assoc
(extract left_add_assoc)  ; Should be equivalent to right_add_assoc
(extract right_add_assoc) ; Should be equivalent to left_add_assoc
(extract not_not_a)       ; Should simplify to bool_a 